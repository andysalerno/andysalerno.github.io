<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xml" href="https://andysalerno.com/feed.xslt.xml"?><feed xmlns="http://www.w3.org/2005/Atom"><generator uri="http://jekyllrb.com" version="3.4.0">Jekyll</generator><link href="https://andysalerno.com/feed.xml" rel="self" type="application/atom+xml" /><link href="https://andysalerno.com/" rel="alternate" type="text/html" /><updated>2017-01-27T22:30:30-08:00</updated><id>https://andysalerno.com//</id><title type="html">/dev/null</title><subtitle>Hello from ~~Chicago~~ ~~St. Louis~~ ~~Kansas City~~ the pacific northwest.
</subtitle><entry><title type="html">Winning Reversi with Monte Carlo Tree Search</title><link href="https://andysalerno.com/2016/03/Monte-Carlo-Reversi" rel="alternate" type="text/html" title="Winning Reversi with Monte Carlo Tree Search" /><published>2016-03-24T00:00:00-07:00</published><updated>2016-03-24T00:00:00-07:00</updated><id>https://andysalerno.com/2016/03/Monte-Carlo-Reversi</id><content type="html" xml:base="https://andysalerno.com/2016/03/Monte-Carlo-Reversi">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot;&gt;

&lt;html&gt;
&lt;head&gt;
  &lt;link href='https://fonts.googleapis.com/css?family=Source+Code+Pro' rel='stylesheet' type='text/css'&gt;
&lt;/head&gt;

&lt;style&gt;
p.b0 {
    margin-bottom: 0px;
}

span.c12 {
    font-weight: bold;
    font-size: 150%;
}
span.c1 {
    font-family: 'Source Code Pro';
}
&lt;/style&gt;

&lt;body class=&quot;c11&quot;&gt;
    &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c2&quot;&gt;Last week, like millions of people across the globe, I was captivated by the 5-game match between professional Go player Lee Sedol and Google Deepmind&amp;rsquo;s AlphaGo.&lt;/span&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0 c5&quot;&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c2&quot;&gt;The games sparked my renewed interest in artificial intelligence and machine learning.  For the past few days my goal was to create an AI agent to play the simple game of Reversi (aka Othello).  However, I had one condition: I would never hard code into the agent a strategy or technique to play the game.  In other words, my agent would not be told to prioritize corners, or try to capture many enemy pieces, or to set itself up for the endgame -- it would figure all that out on its own, with purely emergent behavior.&lt;/span&gt;&lt;/p&gt;

    &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c2&quot;&gt;AlphaGo is an immense system which includes two fundamental strategies: reinforcement learning to generate a heatmap of good moves learned from past experience, and then Monte Carlo tree search to further evaluate those positions.&lt;/span&gt;&lt;/p&gt;

    &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c2&quot;&gt;My ultimate goal is to emulate that one-two punch of experience combined with evaluation to master Reversi.  This first post describes the implementation of Monte Carlo tree search, which alone is enough to create a competent Reversi agent.&lt;/span&gt;&lt;/p&gt;

    &lt;p class=&quot;c0 c5&quot;&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c2&quot;&gt;(This post is not meant to provide any new insights into MCTS, it is meant to show the uninitiated how one person built one such agent with no experience beforehand).&lt;/span&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0 c5&quot;&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c2 c12&quot;&gt;Why Reversi&lt;/span&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c2&quot;&gt;The game of Reversi was picked because it has a similar presentation to the game Go, with a much, much smaller state space.&lt;/span&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0 c5&quot;&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c2&quot;&gt;In Reversi, you can&amp;rsquo;t play a piece anywhere you want -- your placement must &amp;ldquo;trap&amp;rdquo; some amount of enemy stones between your new piece and an existing piece of your color. &amp;nbsp;For example, in this board state:&lt;/span&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0 c5&quot;&gt;
    &lt;/p&gt;


    &lt;p class=&quot;b0&quot;&gt;&lt;span class=&quot;c4&quot;&gt;7 - - - - - - - -&lt;/span&gt;
    &lt;/p&gt;


    &lt;p class=&quot;b0&quot;&gt;&lt;span class=&quot;c4&quot;&gt;6 - - - - - - - -&lt;/span&gt;
    &lt;/p&gt;


    &lt;p class=&quot;b0&quot;&gt;&lt;span class=&quot;c4&quot;&gt;5 - - - - - - - -&lt;/span&gt;
    &lt;/p&gt;


    &lt;p class=&quot;b0&quot;&gt;&lt;span class=&quot;c4&quot;&gt;4 - - - O O O - -&lt;/span&gt;
    &lt;/p&gt;


    &lt;p class=&quot;b0&quot;&gt;&lt;span class=&quot;c4&quot;&gt;3 - - - X X X - -&lt;/span&gt;
    &lt;/p&gt;


    &lt;p class=&quot;b0&quot;&gt;&lt;span class=&quot;c4&quot;&gt;2 - - - - - - - -&lt;/span&gt;
    &lt;/p&gt;


    &lt;p class=&quot;b0&quot;&gt;&lt;span class=&quot;c4&quot;&gt;1 - - - - - - - -&lt;/span&gt;
    &lt;/p&gt;


    &lt;p class=&quot;b0&quot;&gt;&lt;span class=&quot;c4&quot;&gt;0 - - - - - - - -&lt;/span&gt;
    &lt;/p&gt;


    &lt;p class=&quot;b0&quot;&gt;&lt;span class=&quot;c4&quot;&gt;&amp;nbsp; 0 1 2 3 4 5 6 7&lt;/span&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0 c5&quot;&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c2&quot;&gt;If you (black, represented by &amp;lsquo;X&amp;rsquo;) play at (5,5), the resulting board state would be this:&lt;/span&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0 c5&quot;&gt;
    &lt;/p&gt;


    &lt;p class=&quot;b0&quot;&gt;&lt;span class=&quot;c4&quot;&gt;7 - - - - - - - -&lt;/span&gt;
    &lt;/p&gt;


    &lt;p class=&quot;b0&quot;&gt;&lt;span class=&quot;c4&quot;&gt;6 - - - - - - - -&lt;/span&gt;
    &lt;/p&gt;


    &lt;p class=&quot;b0&quot;&gt;&lt;span class=&quot;c4&quot;&gt;5 - - - - - X - -&lt;/span&gt;
    &lt;/p&gt;


    &lt;p class=&quot;b0&quot;&gt;&lt;span class=&quot;c4&quot;&gt;4 - - - O X X - -&lt;/span&gt;
    &lt;/p&gt;


    &lt;p class=&quot;b0&quot;&gt;&lt;span class=&quot;c4&quot;&gt;3 - - - X X X - -&lt;/span&gt;
    &lt;/p&gt;


    &lt;p class=&quot;b0&quot;&gt;&lt;span class=&quot;c4&quot;&gt;2 - - - - - - - -&lt;/span&gt;
    &lt;/p&gt;


    &lt;p class=&quot;b0&quot;&gt;&lt;span class=&quot;c4&quot;&gt;1 - - - - - - - -&lt;/span&gt;
    &lt;/p&gt;


    &lt;p class=&quot;b0&quot;&gt;&lt;span class=&quot;c4&quot;&gt;0 - - - - - - - -&lt;/span&gt;
    &lt;/p&gt;


    &lt;p class=&quot;b0&quot;&gt;&lt;span class=&quot;c4&quot;&gt;&amp;nbsp; 0 1 2 3 4 5 6 7&lt;/span&gt;
    &lt;/p&gt;


    &lt;p class=&quot;b0 c5&quot;&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c2&quot;&gt;You flipped white&amp;rsquo;s pieces at (5,4) and (4,4) because you trapped them between your pieces at (5,3) and (3,3), respectively. &amp;nbsp;Captures radiate out in all directions, including diagonally, and for any length of pieces (as long as they become surrounded on two ends by your color, you have trapped the enemy pieces).  Captures only occur from the piece you played that turn -- if flipping your captured pieces traps more enemy pieces, they do not become captured as well.&lt;/span&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0 c5&quot;&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c2 c12&quot;&gt;Minimax vs Monte Carlo Tree Search&lt;/span&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c2&quot;&gt;Minimax is probably the most intuitive algorithm for decision making in turn based games. &amp;nbsp;It&amp;rsquo;s very similar to how humans think during gameplay: what&amp;rsquo;s the worst thing my opponent can do if I make this move? &amp;nbsp;This move? &amp;nbsp;With several recursive plies (or even recursing to the end of the game if it&amp;rsquo;s computationally feasible), you can be guaranteed to minimize your losses and thereby, hopefully, win.&lt;/span&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0 c5&quot;&gt;
    &lt;/p&gt;


    &lt;p class=&quot;b0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;function minimax(gamestate, maxdepth, curdepth):&lt;/span&gt;
    &lt;/p&gt;


    &lt;p class=&quot;b0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if curdepth == maxdepth or gamestate is a winning state:&lt;/span&gt;
    &lt;/p&gt;


    &lt;p class=&quot;b0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return evaluate(gamestate) # evaluation function&lt;/span&gt;
    &lt;/p&gt;


    &lt;p class=&quot;b0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;else&lt;/span&gt;
    &lt;/p&gt;


    &lt;p class=&quot;b0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;s1, s2, &amp;hellip; sn are successor states of gamestate&lt;/span&gt;
    &lt;/p&gt;


    &lt;p class=&quot;b0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if gamestate is on your turn:&lt;/span&gt;
    &lt;/p&gt;


    &lt;p class=&quot;b0&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return max(minimax(s1, maxdepth, curdepth+1), &amp;hellip;)&lt;/span&gt;
    &lt;/p&gt;


    &lt;p class=&quot;b0 c7&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;else if gamestate is on your opponent&amp;rsquo;s turn:&lt;/span&gt;
    &lt;/p&gt;


    &lt;p class=&quot;b0 c9&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return min(minimax(s1, maxdepth, curdepth+1) &amp;hellip;)&lt;/span&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0 c5&quot;&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c2&quot;&gt;There are several downsides to Minimax.  One is that the branching factor for some games (Go, for instance) is so large that you couldn’t possibly compute more than a few plies ahead (a plie is a turn).  Another is that you need some way to evaluate the state of the game as you are playing it.  That is, to decide the worst thing your opponent can do next turn, you need some notion of what is “bad” and what is “good.”  In checkers, you could say that hopping an opponent’s piece is good, and having your own piece hopped is bad.  So you would craft an evaluation function that returns a higher value for states in which you hop enemy pieces than for states in which you don’t.  It might look something like this:&lt;/span&gt;&lt;/p&gt;

    &lt;script src=&quot;https://gist.github.com/andysalerno/4174c81757d8f81313e4.js&quot;&gt;&lt;/script&gt;

    &lt;p class=&quot;c0 c5&quot;&gt;
    &lt;/p&gt;

    &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c2&quot;&gt;This is an extremely simplistic evaluation function, but it captures the essence.  When running Minimax, your agent would use this function to determine which states have maximum score and which have minimum score.  It will “like” states in which you have more pieces than your opponent, and “dislike” the opposite.&lt;/span&gt;&lt;/p&gt;

    &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c2&quot;&gt;Why is this bad? &amp;nbsp;It doesn&amp;rsquo;t sound like a downside. &amp;nbsp;Humans think that way, after all. &amp;nbsp;But it&amp;rsquo;s undesirable for a few reasons. &amp;nbsp;By telling the agent how to score a state, you are limiting its ability to get &amp;ldquo;creative.&amp;rdquo; &amp;nbsp;An evaluation function that always prefers keeping pieces alive might never lead to a clever move where the agent can sacrifice its own piece to gain a better overall position. &amp;nbsp;The world of AI is much more exciting when the agents are determining the value of states on their own.&lt;/span&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0 c5&quot;&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c2&quot;&gt;Enter Monte Carlo tree search. &amp;nbsp;When I first read how MCTS works, I laughed out loud, because it sounds too ridiculous to work. &amp;nbsp;The gist of it is this: every time it is your turn, determine all the possible moves you can make. &amp;nbsp;For each of those moves, run as many (totally random) simulations as you can, tallying up the win/played ratios of each move. &amp;nbsp;Once your simulations are done, make the move which you simulated the most (you might expect that we&amp;rsquo;d pick the move that&lt;/span&gt; &lt;span class=&quot;c8 c2&quot;&gt;won&lt;/span&gt; &lt;span class=&quot;c2&quot;&gt;the most -- I&amp;rsquo;ll get to that). &amp;nbsp;It sounds crazy at first -- if you&amp;rsquo;re playing a world champion, what good do&lt;/span&gt; &lt;span class=&quot;c8 c2&quot;&gt;random simulations&lt;/span&gt; &lt;span class=&quot;c2&quot;&gt;do you? &amp;nbsp;The pro sure isn&amp;rsquo;t going to play randomly.&lt;/span&gt;&lt;/p&gt;


    &lt;p class=&quot;c0 c5&quot;&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c2&quot;&gt;Well, for one, given enough time MCTS actually converges to Minimax. &amp;nbsp;But instead of trying to calculate a million different ways to play the next&lt;/span&gt; &lt;span class=&quot;c8 c2&quot;&gt;five&lt;/span&gt;&lt;span class=&quot;c2&quot;&gt;&amp;nbsp;turns (Minimax), you play a&lt;/span&gt; &lt;span class=&quot;c8 c2&quot;&gt;million&lt;/span&gt; &lt;span class=&quot;c2&quot;&gt;turns randomly&lt;/span&gt; &lt;span class=&quot;c8 c2&quot;&gt;to completion.&lt;/span&gt;&lt;span class=&quot;c2&quot;&gt;&amp;nbsp; The result of a Minimax evaluation might be the state of the game in five turns, whereas the result of a Monte Carlo simulation will be either a win or a loss. &amp;nbsp;And, after all, that&amp;rsquo;s the goal, isn&amp;rsquo;t it? &amp;nbsp;To win! &amp;nbsp;So the intermediate states of the game don&amp;rsquo;t matter at all -- the only thing we propagate up our tree of game states is how frequently this particular move tends to win (and how frequently the simulation tends to play it).&lt;/span&gt;&lt;/p&gt;


    &lt;p class=&quot;c0 c5&quot;&gt;
    &lt;/p&gt;


    &lt;script src=&quot;https://gist.github.com/andysalerno/f413913f589d9a6ea20c.js&quot;&gt;&lt;/script&gt;

    &lt;p class=&quot;c0 c5&quot;&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c2&quot;&gt;Let me digress for a second to remind you that this is exactly how AlphaGo thinks. &amp;nbsp;It doesn&amp;rsquo;t care how much it wins by -- just that it wins. &amp;nbsp;So while a human might think more like Minimax (&lt;/span&gt;&lt;span class=&quot;c8 c2&quot;&gt;I should make this move because in five turns I&amp;rsquo;ll be in a good spot),&lt;/span&gt; &lt;span class=&quot;c2&quot;&gt;AlphaGo leverages the power of MCTS (&lt;/span&gt;&lt;span class=&quot;c8 c2&quot;&gt;I should make this move because my simulations show it gives me a higher probability to win). &amp;nbsp;&lt;/span&gt;&lt;span class=&quot;c2&quot;&gt;The exciting part is that the result of this project -- which I&amp;rsquo;m getting to, I promise! -- is an agent that shows very similar tendencies to AlphaGo in this regard.&lt;/span&gt;&lt;/p&gt;


    &lt;p class=&quot;c0 c5&quot;&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c2&quot;&gt;In summary: Monte Carlo tree search is exciting because it is goal-oriented, and allows for agents that make some very intriguing moves in their pursuit to win. &amp;nbsp;An agent with a heuristic or evaluation function (like Minimax) might perform better than pure MCTS, but MCTS alone guarantees emergent behavior which I find to be more interesting.&lt;/span&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0 c5&quot;&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c2&quot;&gt;Now let&amp;rsquo;s get down to it.&lt;/span&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0 c5&quot;&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c2 c12&quot;&gt;Building the Game of Reversi&lt;/span&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c2&quot;&gt;The first step was to actually implement the game of Reversi so that my agent has something to play. &amp;nbsp;I&amp;rsquo;ll just show the interface since the implementation isn&amp;rsquo;t hugely important. &amp;nbsp;The code is in Python 3.&lt;/span&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0 c5&quot;&gt;
    &lt;/p&gt;

    &lt;script src=&quot;https://gist.github.com/andysalerno/23d212a3aa6bfbd79005.js&quot;&gt;&lt;/script&gt;
    &lt;p class=&quot;c0 c5&quot;&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c2&quot;&gt;To run our game, we simply need to pass in two agents (one to control each color) to a Reversi object and then call play_game() on it. &amp;nbsp;Every move is printed to stdout.&lt;/span&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0 c5&quot;&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c2 c12&quot;&gt;Monte Carlo Agent&lt;/span&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c2&quot;&gt;Now before we get to our Monte Carlo agent, here is an example agent that makes completely random moves:&lt;/span&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0 c5&quot;&gt;
    &lt;/p&gt;

    &lt;script src=&quot;https://gist.github.com/andysalerno/cff572b90d98163a4de0.js&quot;&gt;&lt;/script&gt;
    &lt;p class=&quot;c0 c5&quot;&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c2&quot;&gt;As we can see from the random agent, we just need to define get_action() by having it return our choice. &amp;nbsp;In our MCTS agent, our get_action() will just call a method named monte_carlo_search(), and return the result. &amp;nbsp;Let&amp;rsquo;s build the top level of monte_carlo_search() now:&lt;/span&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0 c5&quot;&gt;
    &lt;/p&gt;

    &lt;script src=&quot;https://gist.github.com/andysalerno/b776d62fa74d68d7cc74.js&quot;&gt;&lt;/script&gt;

    &lt;p class=&quot;c0 c5&quot;&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c2&quot;&gt;We can see from this that the Monte Carlo search algorithm has several distinct steps. &amp;nbsp;In formal terms, these are: Selection, Expansion, Simulation, and Backpropagation. &amp;nbsp;Some great visuals of those steps&lt;/span&gt; &lt;span class=&quot;c2 c10&quot;&gt;&lt;a class=&quot;c6&quot; href=&quot;https://www.google.com/url?q=https://en.wikipedia.org/wiki/Monte_Carlo_tree_search%23Principle_of_operation&amp;amp;sa=D&amp;amp;ust=1458767681104000&amp;amp;usg=AFQjCNGDGCzG7B_rWZiqQvXKdLLmIenPmQ&quot;&gt;can be seen here at Wikipedia.&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;


    &lt;p class=&quot;c0 c5&quot;&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c2&quot;&gt;In Selection, we traverse our tree by traveling down the nodes with the most promising win:play ratio (this is actually done using a mathematical formula that is more complicated than wins/plays, I&amp;rsquo;ll get to it). &amp;nbsp;Once we reach a leaf of the tree, we Expand that leaf to reveal more nodes. (In our implementation, selection is the method tree_policy())&lt;/span&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0 c5&quot;&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c2&quot;&gt;In Expansion, we generate a new child node (or several) representing the states that could follow from the Selected state. &amp;nbsp;If the Selected state was a win/loss, and therefore has no children, we return that state. &amp;nbsp;Otherwise, we return the newly generated node. (In our implementation, this is bundled into the tree_policy())&lt;/span&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0 c5&quot;&gt;
    &lt;/p&gt;

    &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c2&quot;&gt;(Note: I am using 'state' and 'node' interchangeably here. A node is simply a container for a state that links it to its parent and children states, and also will hold the win/play stats when we update our tree.)


    &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c2&quot;&gt;In Simulation, we run a single random simulation from the node that Expansion generated. &amp;nbsp;The simulation makes random moves for each player until the end of the game, and then returns some value representing the result of the simulation -- a win or a loss.&lt;/span&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0 c5&quot;&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c2&quot;&gt;In Backpropagation, we take the result of the Simulation and propagate it up the tree, starting from the node on which we ran the simulation and ending at the root node (which represented the game state that was passed into the search function). &amp;nbsp;In this step, every node on the path to the root increments its play count by one, and increments its win count by one only if the result was a win.&lt;/span&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0 c5&quot;&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c2&quot;&gt;The Selection-&amp;gt;Expansion-&amp;gt;Simulation-&amp;gt;Backpropagation steps occur as many times as you would like, with more iterations producing better results. &amp;nbsp;In my code, I implemented this using a timer (i.e., you have&lt;/span&gt; &lt;span class=&quot;c8 c2&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;c2&quot;&gt;seconds to run simulations). &amp;nbsp;Another choice would be to fix the amount of simulations that occur, instead of the amount of time you have to do them.&lt;/span&gt;&lt;/p&gt;


    &lt;p class=&quot;c0 c5&quot;&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c2&quot;&gt;Having repeated that process many times, the algorithm now picks the child state of the passed in game state that was played the most amount of times in simulation.&lt;/span&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0 c5&quot;&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c2&quot;&gt;It may seem surprising that we pick the node that was&lt;/span&gt; &lt;span class=&quot;c8 c2&quot;&gt;played&lt;/span&gt; &lt;span class=&quot;c2&quot;&gt;the most, and not the node that won the most amount of games, or that had the highest win percentage. &amp;nbsp;The reason for this is the way that nodes are picked in the Selection step.&lt;/span&gt;&lt;/p&gt;


    &lt;p class=&quot;c0 c5&quot;&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c2&quot;&gt;Let&amp;rsquo;s take a look at our Selection step, implemented by tree_policy():&lt;/span&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0 c5&quot;&gt;
    &lt;/p&gt;

    &lt;script src=&quot;https://gist.github.com/andysalerno/c35eaaf98d1ef2cd1810.js&quot;&gt;&lt;/script&gt;
    &lt;p class=&quot;c0 c5&quot;&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c2&quot;&gt;If you&amp;rsquo;re confused about line 13, I should mention that a game_state object is simply a tuple of a game board object and a constant representing whose turn it is. &amp;nbsp;So if black passes their turn, we convert from a game_state of ({the board}, BLACK) to ({the board}, WHITE). &amp;nbsp;There may be a more elegant way to express this.&lt;/span&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0 c5&quot;&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c2&quot;&gt;You can see that we are traversing the tree by adding child nodes at each state until we&amp;rsquo;ve &amp;ldquo;saturated&amp;rdquo; that state by visiting each of its children at least once. &amp;nbsp;Once we&amp;rsquo;ve done that, we start picking nodes based on the best_child() method. &amp;nbsp;When I said earlier that picking the next node for Selection is more complicated than just the win:play ratio, that&amp;rsquo;s what I meant.&lt;/span&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0 c5&quot;&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c2&quot;&gt;Instead of the win:play ratio, we are going to use an upper confidence bound.&lt;/span&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0 c5&quot;&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c2 c12&quot;&gt;Upper Confidence Bound&lt;/span&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c2&quot;&gt;In &amp;ldquo;vanilla&amp;rdquo; MCTS, in the Selection phase we can pick the nodes to traverse however we want: most wins, highest win percentage, etc.&lt;/span&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0 c5&quot;&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c2&quot;&gt;However, it turns out that picking which node to visit next is a representation of the&lt;/span&gt; &lt;span class=&quot;c10 c2&quot;&gt;&lt;a class=&quot;c6&quot; href=&quot;https://www.google.com/url?q=https://en.wikipedia.org/wiki/Multi-armed_bandit&amp;amp;sa=D&amp;amp;ust=1458767681117000&amp;amp;usg=AFQjCNHaWQdNbslx7FNz411xx1nflk-zsg&quot;&gt;multi-armed bandit problem&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c2&quot;&gt;. &amp;nbsp;I recommend you read the whole Wiki article, but in essence, the multi-armed bandit problem presents you with some amount of choices, with each choice giving you some unknown payoff. &amp;nbsp;Think of several slot machines, where each machine has some fixed but unknown chance to win. &amp;nbsp;The more you play each machine, the more you learn about its payoff rate. &amp;nbsp;The goal is to balance exploration (&amp;ldquo;I don&amp;rsquo;t know much about that machine yet, I should give it a try&amp;rdquo;) with gaining value (&amp;ldquo;I know this machine is paying off really well so I should keep using it&amp;rdquo;). If you think about it, this a direct restatement of our current problem: we have some amount of legal moves we can make.  Each time we test a move, we become more sure of its win rate, but we only have a limited time to run tests, so how much should we test each move?&lt;/span&gt;&lt;/p&gt;


    &lt;p class=&quot;c0 c5&quot;&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c2&quot;&gt;Luckily, this problem is very well known, and some very clever people named&lt;/span&gt; &lt;span class=&quot;c2&quot;&gt;&lt;a href=&quot;http://www.sztaki.hu/~szcsaba/papers/ecml06.pdf&quot;&gt;Kocsis and Szepesv&amp;aacute;ri&lt;/a&gt; came up with a good solution. &amp;nbsp;It&amp;rsquo;s called an upper confidence bound, and it looks like this:&lt;/span&gt;&lt;/p&gt;


    &lt;p class=&quot;c0 c5&quot;&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c3 c2&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 102.00px; height: 51.00px;&quot;&gt;&lt;img alt=&quot;\frac{w_i}{n_i} + c\sqrt{\frac{\ln t}{n_i}}&quot; src=&quot;https://andysalerno.com/images/image00.png&quot; style=&quot;width: 102.00px; height: 51.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);&quot; title=&quot;&quot;&gt;&lt;/span&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0 c5&quot;&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c2 c3&quot;&gt;We operate this equation on each child node, and select the one with the maximum value. &amp;nbsp;Here,&lt;/span&gt; &lt;span class=&quot;c3 c8 c2&quot;&gt;wi&lt;/span&gt; &lt;span class=&quot;c3 c2&quot;&gt;is the amount of wins the node has seen,&lt;/span&gt; &lt;span class=&quot;c3 c8 c2&quot;&gt;ni&lt;/span&gt; &lt;span class=&quot;c3 c2&quot;&gt;is the amount of times it has been played,&lt;/span&gt; &lt;span class=&quot;c3 c8 c2&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;c3 c2&quot;&gt;is the amount of simulations its parent node has seen, and&lt;/span&gt; &lt;span class=&quot;c3 c8 c2&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;c3 c2&quot;&gt;is some fixed constant that you can increase or decrease to be more or less &amp;ldquo;exploration-oriented&amp;rdquo;, respectably. &amp;nbsp;Most sources I&amp;rsquo;ve read deem sqrt(2) to be a good C value, and it&amp;rsquo;s the one I used.&lt;/span&gt;&lt;/p&gt;


    &lt;p class=&quot;c0 c5&quot;&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c3 c2&quot;&gt;Let&amp;rsquo;s take a look at our our best_child() method to see this implementation:&lt;/span&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0 c5&quot;&gt;
    &lt;/p&gt;

    &lt;script src=&quot;https://gist.github.com/andysalerno/5e44410f1d6cba4c2319.js&quot;&gt;&lt;/script&gt;
    &lt;p class=&quot;c0 c5&quot;&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c3 c2&quot;&gt;This upper confidence bound is the reason we always pick the child with the most plays as our ultimate decision in MCTS. &amp;nbsp;The upper confidence bound will prefer those valuable children to run more simulations, which correlates to a better win rate. &amp;nbsp;Of course, when more than one node are tied for the most amount of play counts, we can break ties with their win counts.&lt;/span&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0 c5&quot;&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c3 c2&quot;&gt;Almost done! &amp;nbsp;Now we just have to backpropagate:&lt;/span&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0 c5&quot;&gt;
    &lt;/p&gt;

    &lt;script src=&quot;https://gist.github.com/andysalerno/1250a2203ab7d8da3d10.js&quot;&gt;&lt;/script&gt;
    &lt;p class=&quot;c0 c5&quot;&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c3 c2&quot;&gt;And then return the child node that saw the most amount of plays (aka simulations):&lt;/span&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0 c5&quot;&gt;
    &lt;/p&gt;

    &lt;script src=&quot;https://gist.github.com/andysalerno/f354afb0ab033a6e610f.js&quot;&gt;&lt;/script&gt;

    &lt;p class=&quot;c0 c5&quot;&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c3 c2&quot;&gt;There you have it! &amp;nbsp;Given a state of the game, we performed simulations to determine the best possible next move, all without needing to tell the agent what makes a move good or bad.&lt;/span&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0 c5&quot;&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c3 c2 c12&quot;&gt;Optimizations and Modifications&lt;/span&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c3 c2&quot;&gt;I&amp;rsquo;m sure people reading this might notice potential areas for optimization or improvement. &amp;nbsp;My own implementation went through several iterations after I used Python&amp;rsquo;s profiler to pick out the biggest offenders. &amp;nbsp;One huge improvement you can make is to keep a global mapping of each state you expand to the node you build for it. &amp;nbsp;Then, when monte_carlo_search(game_state) is called, check to see if you already have a node created for that state from past turns. &amp;nbsp;If you do, use it! &amp;nbsp;You can gain some &amp;ldquo;free simulations&amp;rdquo; that way.&lt;/span&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0 c5&quot;&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c3 c2&quot;&gt;I generally prefer the encapsulation approach of never accessing member variables of an object directly, but in the case of running hundreds to thousands of simulations per second, the overhead of many getter methods was really adding up. &amp;nbsp;Therefore, I began accessing variables directly (such as node.game_state) instead of via getters, for a moderate performance increase.&lt;/span&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0 c5&quot;&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c3 c2 c12&quot;&gt;Results&lt;/span&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c3 c2&quot;&gt;The final monte-carlo Reversi agent is pretty strong! &amp;nbsp;I am personally unable to beat it when giving it more than two seconds of simulation time per move. &amp;nbsp;For science, I went online to several Reversi multiplayer websites, and tested the agent against real humans. &amp;nbsp;With a simulation time of two to four seconds I could beat most players, and with a simulation of eight seconds I could beat nearly all players with few exceptions. &amp;nbsp;(Sorry to those websites -- I&amp;rsquo;m sure using a bot is against their terms. &amp;nbsp;But it was for learning!)&lt;/span&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0 c5&quot;&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c3 c2&quot;&gt;The most exciting aspect of this agent (to me) is that it will frequently seem behind and yet display a high confidence rating. &amp;nbsp;If you print out the win/play counts for each considered legal move at each turn, you can see how sure the agent is of its moves. &amp;nbsp;&lt;/span&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0 c5&quot;&gt;
    &lt;/p&gt;

    &lt;p class=&quot;c2&quot;&gt;&lt;span class=&quot;c3&quot;&gt;Playing against the agent, I continuously found myself in situations where I thought I was far ahead, with no chance of losing, only to see my lead slip away. &amp;nbsp;Here was the board state in the middle of one game in particular, me playing as Black:&lt;/span&gt;&lt;/p&gt;
    &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c4&quot;&gt;&lt;/span&gt;&lt;/p&gt;
    &lt;p class=&quot;c2&quot;&gt;&lt;span class=&quot;c4&quot;&gt;Enter a move x,y (or pass to pass): 7,7&lt;br&gt;Black plays at (7, 7)&lt;br&gt;7 - X - - - - - X &lt;br&gt;6 - - X - - - X - &lt;br&gt;5 - - - X X X X - &lt;br&gt;4 - - - O X X - - &lt;br&gt;3 X X O X X O X X &lt;br&gt;2 X X X X - O - - &lt;br&gt;1 - X X - X O - - &lt;br&gt;0 X X X - - - - - &lt;br&gt; &amp;nbsp;0 1 2 3 4 5 6 7&lt;/span&gt;&lt;/p&gt;
    &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c4&quot;&gt;&lt;/span&gt;&lt;/p&gt;
    &lt;p class=&quot;c2&quot;&gt;&lt;span class=&quot;c3&quot;&gt;Two corners, a huge majority of the board under my control. &amp;nbsp;Seems impossible to lose from here.&lt;/span&gt;&lt;/p&gt;
    &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
    &lt;p class=&quot;c2&quot;&gt;&lt;span class=&quot;c3&quot;&gt;A few turns later, the agent was seeing itself win 30/70 simulated games. &amp;nbsp;I figured I would keep increasing the gap until my victory:&lt;/span&gt;&lt;/p&gt;
    &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
    &lt;p class=&quot;c2&quot;&gt;&lt;span class=&quot;c4&quot;&gt;(4, 6): (25/62)&lt;br&gt;(7, 6): (13/42)&lt;br&gt;(3, 0): (14/44)&lt;br&gt;(1, 6): (7/31)&lt;br&gt;(3, 1): (11/39)&lt;br&gt;(7, 4): (30/70)&lt;br&gt;(5, 6): (5/26)&lt;br&gt;306 simulations performed.&lt;br&gt;White plays at (7, 4)&lt;br&gt;7 - X - X - - - X &lt;br&gt;6 - - X X - - X - &lt;br&gt;5 - - X X X X X - &lt;br&gt;4 - - X X X X - O &lt;br&gt;3 X X X X O O O X &lt;br&gt;2 X X X X - O - - &lt;br&gt;1 - X X - X O - - &lt;br&gt;0 X X X - - - - - &lt;br&gt; &amp;nbsp;0 1 2 3 4 5 6 7&lt;/span&gt;&lt;/p&gt;
    &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c4&quot;&gt;&lt;/span&gt;&lt;/p&gt;
    &lt;p class=&quot;c2&quot;&gt;&lt;span class=&quot;c3&quot;&gt;Imagine my surprise when the agent suddenly saw a spike in its win/play ratio, despite my apparent board advantage: &lt;/span&gt;&lt;/p&gt;
    &lt;p class=&quot;c2&quot;&gt;&lt;span class=&quot;c4&quot;&gt;(4, 7): (9/30)&lt;br&gt;(0, 7): (50/88)&lt;br&gt;(0, 1): (2/18)&lt;br&gt;(7, 6): (4/22)&lt;br&gt;(1, 4): (31/63)&lt;br&gt;(1, 5): (13/37)&lt;br&gt;(5, 6): (14/38)&lt;br&gt;(7, 5): (8/29)&lt;br&gt;(1, 6): (5/24)&lt;br&gt;(3, 1): (24/53)&lt;br&gt;(7, 2): (12/35)&lt;br&gt;433 simulations performed.&lt;br&gt;White plays at (0, 7)&lt;br&gt;7 O O O X - - - X &lt;br&gt;6 - - X O - - X - &lt;br&gt;5 - - X X O X X - &lt;br&gt;4 - - X X X O - O &lt;br&gt;3 X X X X X X O X &lt;br&gt;2 X X X X X O - - &lt;br&gt;1 - X X - X X - - &lt;br&gt;0 X X X X X X - - &lt;br&gt; &amp;nbsp;0 1 2 3 4 5 6 7&lt;/span&gt;&lt;/p&gt;
    &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c4&quot;&gt;&lt;/span&gt;&lt;/p&gt;
    &lt;p class=&quot;c2&quot;&gt;&lt;span class=&quot;c3&quot;&gt;Sure, it had taken one corner, but I was on my way to three. &amp;nbsp;It has a nice diagonal going from (2,7) to (6,3), but that couldn&amp;rsquo;t be enough to win it the game, right?&lt;/span&gt;&lt;/p&gt;
    &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
    &lt;p class=&quot;c2&quot;&gt;&lt;span class=&quot;c3&quot;&gt;Several turns later, White had managed to create another diagonal slice, splitting me in two. &amp;nbsp;With another bump in its win/play confidence:&lt;/span&gt;&lt;/p&gt;
    &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
    &lt;p class=&quot;c2&quot;&gt;&lt;span class=&quot;c4&quot;&gt;(7, 1): (50/89)&lt;br&gt;(0, 1): (39/74)&lt;br&gt;(7, 2): (115/171)&lt;br&gt;(3, 1): (137/198)&lt;br&gt;(6, 1): (216/293)&lt;br&gt;790 simulations performed.&lt;br&gt;White plays at (6, 1)&lt;br&gt;7 O O O O O - - X &lt;br&gt;6 - O O O - - X - &lt;br&gt;5 - - O X O X X X &lt;br&gt;4 X X X O X X X X &lt;br&gt;3 X X X X O X X X &lt;br&gt;2 X X X X X O X - &lt;br&gt;1 - X X - X X O - &lt;br&gt;0 X X X X X X - - &lt;br&gt; &amp;nbsp;0 1 2 3 4 5 6 7&lt;/span&gt;&lt;/p&gt;
    &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c4&quot;&gt;&lt;/span&gt;&lt;/p&gt;
    &lt;p class=&quot;c2&quot;&gt;&lt;span class=&quot;c3&quot;&gt;A few more turns later, I see my chance to take a third corner, so I do. &amp;nbsp;But apparently White doesn&amp;rsquo;t care, because its win/play confidence didn&amp;rsquo;t budge. &amp;nbsp;The board, which had looked great for me several turns back, begins to look ominously White:&lt;/span&gt;&lt;/p&gt;
    &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
    &lt;p class=&quot;c2&quot;&gt;&lt;span class=&quot;c4&quot;&gt;(0, 5): (49/83)&lt;br&gt;(0, 1): (25/52)&lt;br&gt;(7, 1): (142/193)&lt;br&gt;(7, 2): (183/240)&lt;br&gt;(3, 1): (258/322)&lt;br&gt;(7, 6): (229/291)&lt;br&gt;1162 simulations performed.&lt;br&gt;White plays at (3, 1)&lt;br&gt;7 O O O O O - - X &lt;br&gt;6 - O O O - O X - &lt;br&gt;5 - X X O O O X X &lt;br&gt;4 X X X O X O X X &lt;br&gt;3 X X X O X O X X &lt;br&gt;2 X X X O O X X - &lt;br&gt;1 - X X O X X X - &lt;br&gt;0 X X X X X X - X &lt;br&gt; &amp;nbsp;0 1 2 3 4 5 6 7&lt;/span&gt;&lt;/p&gt;
    &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c4&quot;&gt;&lt;/span&gt;&lt;/p&gt;
    &lt;p class=&quot;c2&quot;&gt;&lt;span class=&quot;c3&quot;&gt;Then, a few moves later, the killing blow. &amp;nbsp;White makes a move that it believes will win the game 686/692 times, even though it doesn&amp;rsquo;t seem like that big of a move to me:&lt;/span&gt;&lt;/p&gt;
    &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
    &lt;p class=&quot;c2&quot;&gt;&lt;span class=&quot;c4&quot;&gt;(6, 0): (120/147)&lt;br&gt;(7, 1): (20/39)&lt;br&gt;(0, 6): (82/108)&lt;br&gt;(7, 2): (55/79)&lt;br&gt;(6, 7): (288/313)&lt;br&gt;(7, 6): (686/692)&lt;br&gt;(0, 5): (115/142)&lt;br&gt;(0, 1): (78/103)&lt;br&gt;1494 simulations performed.&lt;br&gt;White plays at (7, 6)&lt;br&gt;7 O O O O O X - X &lt;br&gt;6 - O O O - X X O &lt;br&gt;5 - X X O O X O X &lt;br&gt;4 X X X O X O X X &lt;br&gt;3 X X X O O X X X &lt;br&gt;2 X X X O O X X - &lt;br&gt;1 - X X O X X X - &lt;br&gt;0 X X X X X X - X &lt;br&gt; &amp;nbsp;0 1 2 3 4 5 6 7&lt;/span&gt;&lt;/p&gt;
    &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c4&quot;&gt;&lt;/span&gt;&lt;/p&gt;
    &lt;p class=&quot;c2&quot;&gt;&lt;span class=&quot;c3&quot;&gt;This is the sort of devious planning that can emerge from the chaos of random simulation. &amp;nbsp;I can&amp;rsquo;t help but feel outsmarted.&lt;/span&gt;&lt;/p&gt;
    &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
    &lt;p class=&quot;c2&quot;&gt;&lt;span class=&quot;c3&quot;&gt;Even though it might feel like I still have a fighting chance, it&amp;rsquo;s game over. &amp;nbsp;White has entered a position where the win is guaranteed. &amp;nbsp;After this move it couldn&amp;rsquo;t lose if it tried, despite having only 20 pieces while I have 38:&lt;/span&gt;&lt;/p&gt;
    &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
    &lt;p class=&quot;c2&quot;&gt;&lt;span class=&quot;c4&quot;&gt;(7, 1): (304/311)&lt;br&gt;(7, 2): (382/382)&lt;br&gt;(0, 6): (382/382)&lt;br&gt;(0, 5): (382/382)&lt;br&gt;(0, 1): (382/382)&lt;br&gt;(6, 7): (382/382)&lt;br&gt;(6, 0): (338/342)&lt;br&gt;1873 simulations performed.&lt;br&gt;White plays at (0, 6)&lt;br&gt;7 O O O O O X - X &lt;br&gt;6 O O O O X X X O &lt;br&gt;5 - O X X X X O X &lt;br&gt;4 X X O O X O X X &lt;br&gt;3 X X X O O X X X &lt;br&gt;2 X X X O O X X - &lt;br&gt;1 - X X O X X X - &lt;br&gt;0 X X X X X X - X &lt;br&gt; &amp;nbsp;0 1 2 3 4 5 6 7&lt;/span&gt;&lt;/p&gt;
    &lt;p class=&quot;c2&quot;&gt;&lt;span class=&quot;c4&quot;&gt;(White: 20 Black: 38)&lt;/span&gt;&lt;/p&gt;
    &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c4&quot;&gt;&lt;/span&gt;&lt;/p&gt;
    &lt;p class=&quot;c2&quot;&gt;&lt;span class=&quot;c3&quot;&gt;Examine this board for a second and see if you can figure out how White has a guaranteed win. &amp;nbsp;Black only has one move, at (0,5). &amp;nbsp;This opens up White to capture a huge amount by playing&amp;hellip; pretty much anywhere. &amp;nbsp;And that&amp;rsquo;s what it does. &amp;nbsp;I&amp;rsquo;m going to paste here the final moves of the game. &amp;nbsp;Follow along and watch my kingdom topple:&lt;/span&gt;&lt;/p&gt;
    &lt;p class=&quot;c1&quot;&gt;&lt;span class=&quot;c3&quot;&gt;&lt;/span&gt;&lt;/p&gt;
    &lt;p class=&quot;c2&quot;&gt;&lt;span class=&quot;c4&quot;&gt;Enter a move x,y (or pass to pass): 0,5&lt;br&gt;Black plays at (0, 5)&lt;br&gt;7 O O O O O X - X &lt;br&gt;6 O O O O X X X O &lt;br&gt;5 X X X X X X O X &lt;br&gt;4 X X O O X O X X &lt;br&gt;3 X X X O O X X X &lt;br&gt;2 X X X O O X X - &lt;br&gt;1 - X X O X X X - &lt;br&gt;0 X X X X X X - X &lt;br&gt; &amp;nbsp;0 1 2 3 4 5 6 7 &lt;br&gt;&lt;br&gt;(0, 1): (605/605)&lt;br&gt;(6, 7): (605/605)&lt;br&gt;(7, 2): (605/605)&lt;br&gt;(6, 0): (606/606)&lt;br&gt;(7, 1): (605/605)&lt;br&gt;2646 simulations performed.&lt;br&gt;White plays at (6, 0)&lt;br&gt;7 O O O O O X - X &lt;br&gt;6 O O O O X X X O &lt;br&gt;5 X X X X X X O X &lt;br&gt;4 X X O O X O O X &lt;br&gt;3 X X X O O X O X &lt;br&gt;2 X X X O O X O - &lt;br&gt;1 - X X O X O O - &lt;br&gt;0 X X X X X X O X &lt;br&gt; &amp;nbsp;0 1 2 3 4 5 6 7 &lt;br&gt;&lt;br&gt;Enter a move x,y (or pass to pass): 7,1&lt;br&gt;Black plays at (7, 1)&lt;br&gt;7 O O O O O X - X &lt;br&gt;6 O O O O X X X O &lt;br&gt;5 X X X X X X O X &lt;br&gt;4 X X O O X O O X &lt;br&gt;3 X X X O O X O X &lt;br&gt;2 X X X O O X X - &lt;br&gt;1 - X X O X X X X &lt;br&gt;0 X X X X X X O X &lt;br&gt; &amp;nbsp;0 1 2 3 4 5 6 7 &lt;br&gt;&lt;br&gt;(7, 2): (1539/1539)&lt;br&gt;(6, 7): (1539/1539)&lt;br&gt;(0, 1): (1538/1538)&lt;br&gt;4609 simulations performed.&lt;br&gt;White plays at (6, 7)&lt;br&gt;7 O O O O O O O X &lt;br&gt;6 O O O O X O O O &lt;br&gt;5 X X X X O X O X &lt;br&gt;4 X X O O X O O X &lt;br&gt;3 X X X O O X O X &lt;br&gt;2 X X X O O X X - &lt;br&gt;1 - X X O X X X X &lt;br&gt;0 X X X X X X O X &lt;br&gt; &amp;nbsp;0 1 2 3 4 5 6 7 &lt;br&gt;&lt;br&gt;Black had no moves, and passed their turn.&lt;br&gt;7 O O O O O O O X &lt;br&gt;6 O O O O X O O O &lt;br&gt;5 X X X X O X O X &lt;br&gt;4 X X O O X O O X &lt;br&gt;3 X X X O O X O X &lt;br&gt;2 X X X O O X X - &lt;br&gt;1 - X X O X X X X &lt;br&gt;0 X X X X X X O X &lt;br&gt; &amp;nbsp;0 1 2 3 4 5 6 7 &lt;br&gt;&lt;br&gt;(0, 1): (2879/2879)&lt;br&gt;(7, 2): (2879/2879)&lt;br&gt;5757 simulations performed.&lt;br&gt;White plays at (0, 1)&lt;br&gt;7 O O O O O O O X &lt;br&gt;6 O O O O X O O O &lt;br&gt;5 O X X X O X O X &lt;br&gt;4 O X O O X O O X &lt;br&gt;3 O X O O O X O X &lt;br&gt;2 O O X O O X X - &lt;br&gt;1 O O O O X X X X &lt;br&gt;0 X X X X X X O X &lt;br&gt; &amp;nbsp;0 1 2 3 4 5 6 7 &lt;br&gt;&lt;br&gt;Black had no moves, and passed their turn.&lt;br&gt;7 O O O O O O O X &lt;br&gt;6 O O O O X O O O &lt;br&gt;5 O X X X O X O X &lt;br&gt;4 O X O O X O O X &lt;br&gt;3 O X O O O X O X &lt;br&gt;2 O O X O O X X - &lt;br&gt;1 O O O O X X X X &lt;br&gt;0 X X X X X X O X &lt;br&gt; &amp;nbsp;0 1 2 3 4 5 6 7 &lt;br&gt;&lt;br&gt;(7, 2): (16969/16969)&lt;br&gt;16968 simulations performed.&lt;br&gt;White plays at (7, 2)&lt;br&gt;7 O O O O O O O X &lt;br&gt;6 O O O O X O O O &lt;br&gt;5 O X X X O X O O &lt;br&gt;4 O X O O X O O O &lt;br&gt;3 O X O O O X O O &lt;br&gt;2 O O X O O O O O &lt;br&gt;1 O O O O X X X X &lt;br&gt;0 X X X X X X O X &lt;br&gt; &amp;nbsp;0 1 2 3 4 5 6 7&lt;/span&gt;&lt;/p&gt;

    &lt;p class=&quot;c0 c5&quot;&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c3 c2 c12&quot;&gt;Conclusion&lt;/span&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c3 c2&quot;&gt;You can see my&lt;/span&gt; &lt;span class=&quot;c10 c2 c13&quot;&gt;&lt;a class=&quot;c6&quot; href=&quot;https://www.google.com/url?q=https://github.com/andysalerno/reversi-ai&amp;amp;sa=D&amp;amp;ust=1458767681152000&amp;amp;usg=AFQjCNEO5VWzwfqNPGmy62tr6gQkLnSjgw&quot;&gt;full code for this project on Github.&lt;/a&gt;&lt;/span&gt;&lt;span class=&quot;c3 c2&quot;&gt;&amp;nbsp; Note that there are several small changes in my implementation that I ignored for this writeup to keep it simpler.&lt;/span&gt;&lt;/p&gt;


    &lt;p class=&quot;c0 c5&quot;&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c3 c2&quot;&gt;We&amp;rsquo;re done, right? &amp;nbsp;We made an agent that plays Reversi without being told how to play!&lt;/span&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0 c5&quot;&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c3 c2&quot;&gt;Well, that&amp;rsquo;s true. &amp;nbsp;But my real goal is to&lt;/span&gt; &lt;span class=&quot;c3 c2 c8&quot;&gt;teach&lt;/span&gt; &lt;span class=&quot;c3 c2&quot;&gt;an agent to play. &amp;nbsp;Monte Carlo tree search is&lt;/span&gt; &lt;span class=&quot;c3 c8 c2&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;c3 c2&quot;&gt;a learning algorithm. &amp;nbsp;It hasn&amp;rsquo;t learned to play from experience; instead, it generates its own experiences on the fly each turn. &amp;nbsp;To truly teach an agent how to play Reversi, you&amp;rsquo;d need to let it play against itself thousands to millions of times, learning to play as it goes. &amp;nbsp;This is called reinforcement learning, and we will be implementing it using a technique called Q-Learning&amp;hellip;&lt;/span&gt;&lt;/p&gt;


    &lt;p class=&quot;c0 c5&quot;&gt;
    &lt;/p&gt;


    &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c3 c2&quot;&gt;That part is still coming up! &amp;nbsp;Next time. &amp;nbsp;Thanks for reading.&lt;/span&gt;
    &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c3 c2&quot;&gt;(Did I make any typos or get anything totally wrong? My email address is in the footer.)&lt;/span&gt;

    &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c3 c2 c12&quot;&gt;Resources&lt;/span&gt;
    &lt;/p&gt;
    &lt;a href=&quot;http://www.cameronius.com/cv/mcts-survey-master.pdf&quot;&gt;&lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c3 c2&quot;&gt;Cameron Browne, Edward Powley, Daniel Whitehouse, Simon Lucas, Peter I. Cowling, Philipp Rohlfshagen, Stephen Tavener, Diego Perez, Spyridon Samothrakis, Simon Colton (March 2012). &quot;A Survey of Monte Carlo Tree Search Methods&quot; (PDF). &lt;i&gt;IEEE Transactions on Computational Intelligence and AI in Games 4&lt;/i&gt;&lt;/span&gt;&lt;/a&gt;

    &lt;a href=&quot;https://en.wikipedia.org/wiki/Monte_Carlo_tree_search&quot;&gt;&lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c3 c2&quot;&gt;&quot;Monte Carlo Tree Search&quot;, &lt;i&gt;Wikipedia: The Free Encyclopedia&lt;/i&gt;&lt;/span&gt;&lt;/a&gt;

    &lt;p class=&quot;c0&quot;&gt;&lt;span class=&quot;c3 c2&quot;&gt;
    &lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</content><summary type="html"></summary></entry></feed>
